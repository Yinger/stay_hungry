# 基本架构

## 基本操作集合

- PUT：新写入或更新一个 key-value 对；
- GET：根据一个 key 读取相应的 value 值；
- DELETE：根据一个 key 删除整个 key-value 对。
- SCAN: 根据一段 key 的范围返回相应的 value 值

有些键值数据库的新写 / 更新操作叫 SET

## 键值对保存在内存还是外存

- 保存在内存的好处是读写很快，毕竟内存的访问速度一般都在百 ns 级别。但是，潜在的风险是一旦掉电，所有的数据都会丢失。
- 保存在外存，虽然可以避免数据丢失，但是受限于磁盘的慢速读写（通常在几 ms 级别），键值数据库的整体性能会被拉低。

## 采用什么访问模式

- 通过函数库调用的方式供外部应用使用
- 通过网络框架以 Socket 通信的形式对外提供键值对操作

## 如何定位键值对的位置

索引的作用是让键值数据库根据 key 找到相应 value 的存储位置，进而执行操作

Memcached 和 Redis 采用哈希表作为 key-value 索引，而 RocksDB 则采用跳表作为内存中 key-value 的索引

## 不同操作的具体逻辑是怎样的

- 对于 GET/SCAN 操作而言，此时根据 value 的存储位置返回 value 值即可；
- 对于 PUT 一个新的键值对数据而言，SimpleKV 需要为该键值对分配内存空间；
- 对于 DELETE 操作，SimpleKV 需要删除键值对，并释放相应的内存空间，这个过程由分配器完成。

## 如何实现重启后快速提供服务

采用了常用的内存分配器 glibc 的 malloc 和 free

# 数据结构

## 数据类型

- String
- List
- Hash
- Set
- Sorted Set

## 底层数据结构

- 简单动态字符串 (String) O(1)
- 双向链表 (List) O(n)
- 压缩列表 (List,Hash) O(n)
- 哈希表 (Hash,Set) O(1)
- 跳表 (Sorted Set) O(logN)
- 整数数组 (Set) O(n)

# 持久化

- ## AOF（Append Only File）日志
- AOF 日志是写后日志。
  - 可以避免出现记录错误命令的情况
  - 不会阻塞当前的写操作
- AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。

### 三种写回策略

AOF 机制给我们提供了三个选择，也就是 AOF 配置项 appendfsync 的三个可选值

- Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘
- Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘
- No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘

### AOF 重写机制

在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。

- 重写机制可以把日志文件变小

实际上，重写机制具有“多变一”功能。所谓的“多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。

#### AOF 重写会阻塞吗?

和 AOF 日志由主线程写回不同，重写过程是由后台子进程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。

- 一个拷贝，两处日志

每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。

- ## RDB 快照
