# 平均负载
```
$ uptime
02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88
```

```
02:34:03                      //当前时间
up 2 days, 20:14              //系统运行时间
1 user                        //正在登录用户数
oad average: 0.63, 0.83, 0.88 //平均负载 1 分钟、5 分钟、15 分钟
```

## 什么是平均负载
* 正确定义：单位时间内，系统中处于可运行状态和不可中断状态的平均进程数，也就是 __平均活跃进程数__。
  * 可运行状态的进程：正在使用cpu或者正在等待cpu的进程，即 ps 命令下 STAT 处于 R（Running 或 Runnable）状态的进程
  * 不可中断状态的进程：处于内核态关键流程中的进程，且不可被打断，如等待硬件设备IO响应，ps命令 D（Uninterruptible Sleep，也称为 Disk Sleep）状态的进程
    * 不可中断状态实际上是系统对进程和硬件设备的一种保护机制
  * 理想状态：每个cpu上都有一个活跃进程，即平均负载数等于cpu数
    ```
    比如当平均负载为 2 时，意味着:
    1. 在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。
    2. 在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。
    3. 而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。
    ```
  * 过载经验值：平均负载高于cpu数量70%的时候
* 错误定义：单位时间内的cpu使用率。

## 平均负载与cpu使用率的区别
* CPU使用率：单位时间内cpu繁忙情况的统计
  * 情况1：CPU密集型进程，CPU使用率和平均负载基本一致
  * 情况2：IO密集型进程，平均负载升高，CPU使用率不一定升高
  * 情况3：大量等待CPU的进程调度，平均负载升高，CPU使用率也升高

## 平均负载过高时，如何调优
* Ubuntu 18.04 :2 CPU，8GB 内存
* 工具：stress、sysstat，yum即可安装
  * stress 是一个 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。
  * sysstat 包含了常用的 Linux 性能工具，用来监控和分析系统的性能。
    * mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。
    * pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。

### 1. CPU密集型进程case：
  ```
    # 在第一个终端运行 stress 命令，模拟一个 CPU 使用率 100% 的场景
    $ stress --cpu 1 --timeout 600

    # 在第二个终端运行 uptime 查看平均负载的变化情况
    # -d 参数表示高亮显示变化的区域
    $ watch -d uptime
    ...,  load average: 1.00, 0.75, 0.39

    # 在第三个终端运行 mpstat 查看 CPU 使用率的变化情况
    # -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
    $ mpstat -P ALL 5
    Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)
    13:30:06     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
    13:30:11     all   50.05    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.95
    13:30:11       0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
    13:30:11       1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
  ```

从终端二中可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。
那么，到底是哪个进程导致了 CPU 使用率为 100% 呢？可以使用 pidstat 来查询

  ```
    # 间隔5秒后输出一组数据
    $ pidstat -u 5 1
    13:37:07      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
    13:37:12        0      2962  100.00    0.00    0.00    0.00  100.00     1  stress
  ```

从这里可以明显看到，stress 进程的 CPU 使用率为 100%。


### 2. IO密集型进程case：
  ```
    # 在第一个终端运行 stress 命令 模拟 I/O 压力，即不停地执行 sync
    $ stress -i 1 --timeout 600

    # 在第二个终端运行 uptime 查看平均负载的变化情况
    $ watch -d uptime
    ...,  load average: 1.06, 0.58, 0.37

    # 第三个终端运行 mpstat 查看 CPU 使用率的变化情况
    # 显示所有CPU的指标，并在间隔5秒输出一组数据
    $ mpstat -P ALL 5 1
    Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
    13:41:28     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
    13:41:33     all    0.21    0.00   12.07   32.67    0.00    0.21    0.00    0.00    0.00   54.84
    13:41:33       0    0.43    0.00   23.87   67.53    0.00    0.43    0.00    0.00    0.00    7.74
    13:41:33       1    0.00    0.00    0.81    0.20    0.00    0.00    0.00    0.00    0.00   98.99
  ```

从这里可以看到，1 分钟的平均负载会慢慢增加到 1.06，其中一个 CPU 的系统 CPU 使用率升高到了 23.87，而 iowait 高达 67.53%。这说明，平均负载的升高是由于 iowait 的升高。
那么到底是哪个进程，导致 iowait 这么高呢？还是用 pidstat 来查询

  ```
    # 间隔5秒后输出一组数据，-u表示CPU指标
    $ pidstat -u 5 1
    Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
    13:42:08      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
    13:42:13        0       104    0.00    3.39    0.00    0.00    3.39     1  kworker/1:1H
    13:42:13        0       109    0.00    0.40    0.00    0.00    0.40     0  kworker/0:1H
    13:42:13        0      2997    2.00   35.53    0.00    3.99   37.52     1  stress
    13:42:13        0      3057    0.00    0.40    0.00    0.00    0.40     0  pidstat
  ```

可以发现，还是 stress 进程导致的

### 3. 大量进程case：
当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程
```
  # 在第一个终端运行 stress 命令 模拟 8 个进程
  $ stress -c 8 --timeout 600

  # 在第二个终端运行 uptime 查看平均负载的变化情况
  # 由于系统只有 2 个 CPU，明显比 8 个进程要少得多，因而，系统的 CPU 处于严重过载状态，平均负载高达 7.97
  $ uptime
  ...,  load average: 7.97, 5.93, 3.02

  # 第三个终端运行 pidstat 来看一下进程的情况
  # 间隔5秒后输出一组数据
  $ pidstat -u 5 1
  14:23:25      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
  14:23:30        0      3190   25.00    0.00    0.00   74.80   25.00     0  stress
  14:23:30        0      3191   25.00    0.00    0.00   75.20   25.00     0  stress
  14:23:30        0      3192   25.00    0.00    0.00   74.80   25.00     1  stress
  14:23:30        0      3193   25.00    0.00    0.00   75.00   25.00     1  stress
  14:23:30        0      3194   24.80    0.00    0.00   74.60   24.80     0  stress
  14:23:30        0      3195   24.80    0.00    0.00   75.00   24.80     0  stress
  14:23:30        0      3196   24.80    0.00    0.00   74.60   24.80     1  stress
  14:23:30        0      3197   24.80    0.00    0.00   74.80   24.80     1  stress
  14:23:30        0      3200    0.00    0.20    0.00    0.20    0.20     0  pidstat
```

可以看出，8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间（也就是代码块中的 %wait 列）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。
